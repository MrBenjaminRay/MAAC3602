<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hotkey = ''; // To be overridden
chargingSprite = noone; // To be overridden
abilityName = ''; // To be overridden

lockedSprite = spr_abilityorb_locked;
unlocked = false; // Will be updated in step event for each orb
charged = false; // Will be updated in step event for each orb
sprite = noone; // Will be updated in step event

//keyNumberOffset_x = -20;
//keyNumberOffset_y = -20;
keyNumberOffset_x = -12;
keyNumberOffset_y = -12;

statusTextOffset_x = 24;
statusTextOffset_y = 0;

textShadowOffset_x = 1;
textShadowOffset_y = 1;

// Tooltip hover stuff
toolTipEnabled = false;
mouseHoverTime = 0;
toolTipOffset_x = 28; // May be flipped to negative when toolbar needs to be drawn to the left
toolTipOffset_y = 0;

statusText = '';  // Will be 00:00 or "READY"
statusTextColor = noone; // Override in step events

statusTextReady = ''; // Use this when status is ready (otherwise countdown)
statusTextReadyColor = c_lime; // Color to use when ready
statusTextChargingColor = c_yellow; // Color to use when charging

// Positioning (do all calculations here and let each orb specify which position it will use)

// Set base variables around which the orbs are positioned
posBase_x = global.screenWidth / 4 - 38; // Half way between left and center - offset based on avaibale space
posBase_y = global.screenHeight - 55;
posBaseOffset_x = 60;
posBaseOffset_y = 30;

// Left diamond position
pos1_x = posBase_x - posBaseOffset_x;
pos1_y = posBase_y;

// Top diamond position
pos2_x = posBase_x;
pos2_y = posBase_y - posBaseOffset_y;

// Right diamond position
pos3_x = posBase_x + posBaseOffset_x;
pos3_y = posBase_y;

// Bottom diamond position
pos4_x = posBase_x;
pos4_y = posBase_y + posBaseOffset_y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Do nothing without a player
if (!instance_exists(obj_player)) {
    return 0;
}

// Decide whether or not to show the hover tooltip (baased on player hover time)
if (
    point_in_rectangle(
        window_mouse_get_x(), 
        window_mouse_get_y(), 
        x-sprite_width/2,
        y-sprite_height/2,
        x+sprite_width/2,
        y+sprite_height/2
    )
) {
    if(!toolTipEnabled) {
        mouseHoverTime += global.deltaTime;
    }
} else {
    mouseHoverTime = 0;
}
toolTipEnabled = mouseHoverTime &gt;= 500;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw Icon</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw nothing without a player
if (!instance_exists(obj_player)) {
    return 0;
}

var drawPadlock = false;

// Set the sprite based on the ability status
if (!unlocked) {
    // Still locked
    sprite = lockedSprite;
    drawPadlock = true;
} else if (!charged) {
    // Unlocked and charging
    sprite = chargingSprite;
} else {
    // Unlocked and ready
    sprite = sprite_index;
}

// Draw faded icon when recharging so that countdown text is more obvious
if (!unlocked || unlocked &amp;&amp; !charged) {
    draw_set_alpha(.3);
} else {
    draw_set_alpha(1);
}

if (drawPadlock) {
    // Draw the padlock centered, smaller, and faded
    var lockScale = .65;
    var lockOffset_x = -(sprite_get_width(spr_locked)*lockScale)/2;
    var lockOffset_y = -(sprite_get_height(spr_locked)*lockScale)/2 -2; // Little extra to bump lock sprite up a bit
    draw_sprite_ext(spr_locked, 0, x + lockOffset_x, y + lockOffset_y, lockScale, lockScale, 0, c_white, .5);
}

// DRAW MAIN ICON
draw_sprite(sprite, 0, x, y);

// Reset alpha
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw Hotkey</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// DRAW HOTKEY

// Set the font for the hotkey
draw_set_font(fnt_hud_hotbar_hotkey);

draw_set_halign(fa_right);
draw_set_valign(fa_bottom);

if (unlocked) {
    
    // Reset drawing alignment so we don't screw up other stuff drawn after this
    draw_set_halign(fa_right);
    
    // Draw hotkey shadow
    // Need it to really help the hotkey stand out over the white border
    // of the orb, so we draw 1 shadow in every direction behind the hotkey text
    draw_set_colour(c_black);
    if (!charged) {
        draw_set_alpha(.25);
    } else {
        draw_set_alpha(.75);
    }

    draw_text(
        x + keyNumberOffset_x - textShadowOffset_x,
        y + keyNumberOffset_y + textShadowOffset_y,
        hotkey
    );
    draw_text(
        x + keyNumberOffset_x + textShadowOffset_x,
        y + keyNumberOffset_y - textShadowOffset_y,
        hotkey
    );
    draw_text(
        x + keyNumberOffset_x - textShadowOffset_x,
        y + keyNumberOffset_y - textShadowOffset_y,
        hotkey
    );
    draw_text(
        x + keyNumberOffset_x + textShadowOffset_x,
        y + keyNumberOffset_y + textShadowOffset_y,
        hotkey
    );
    
    // Draw hotkey
    draw_set_colour(c_white);
    if (!charged) {
        draw_set_alpha(.5);
    } else {
        draw_set_alpha(1);
    }
    draw_text(
        x + keyNumberOffset_x,
        y + keyNumberOffset_y,
        hotkey
    );
    
    // Reset alpha
    draw_set_alpha(1);
    
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw Status</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// DRAW STATUS TEXT

draw_set_halign(fa_center);
draw_set_valign(fa_middle);


// Draw status shadow
// Need it to really help the status stand out over the faded icon behind it,
// so we draw 1 shadow in every direction behind the hotkey text
draw_set_colour(c_black);
draw_set_alpha(1);
draw_text(
    round(x) - textShadowOffset_x,
    round(y) + textShadowOffset_y,
    statusText
);
draw_text(
    round(x) + textShadowOffset_x,
    round(y) - textShadowOffset_y,
    statusText
);
draw_text(
    round(x) - textShadowOffset_x,
    round(y) - textShadowOffset_y,
    statusText
);
draw_text(
    round(x) + textShadowOffset_x,
    round(y) + textShadowOffset_y,
    statusText
);

 
// Draw status text
draw_set_colour(statusTextColor);
draw_set_alpha(1);
draw_text(
    round(x), // + statusTextOffset_x,
    round(y), // + statusTextOffset_y,
    statusText
);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw Hover Tooltip</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (toolTipEnabled) {
    // Draw name of ability or generic text if locked
    var text;
    if (unlocked) {
        text = abilityName;
    } else {
        text = 'Locked Ability';
    }

    // Handle horizontal text alignment
    if (toolTipOffset_x &lt; 0) {
        // Tooltip on left of icon, so make it right-aligned
        draw_set_halign(fa_right);
    } else if (toolTipOffset_x &gt; 0) {
        // Tooltip on right of icon, so make it left-aligned
        draw_set_halign(fa_left);
    } else {
        // Tooltip is exactly x, so center it (likely being placed above icon)
        draw_set_halign(fa_center);
    }

    // Handle vertical text alignment
    if (toolTipOffset_y &lt; 0) {
        // Tooltip being placed above icon, so bottom-align the text
        draw_set_valign(fa_bottom);
    } else if (toolTipOffset_y &gt; 0) {
        // Tooltip being placed below the icon, so top-align the text
        draw_set_valign(fa_top);
    } else {
        // Tooltip y offset is exactly y, so center it (likely being placed on left or right of icon)
        draw_set_valign(fa_middle);
    }
    
    // Round values so text is pixel-perfect
    // Draw shadow
    draw_set_alpha(.5);
    draw_set_colour(c_black);
    draw_text(
        round(x) + toolTipOffset_x + textShadowOffset_x,
        round(y) + toolTipOffset_y + textShadowOffset_y,
        text
    );
    // Draw hover text
    draw_set_alpha(1);
    draw_set_colour(c_white);
    draw_text(
        round(x) + toolTipOffset_x,
        round(y) + toolTipOffset_y,
        text
    );
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Reset Draw Stuff</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Reset drawing alignment so we don't screw up other stuff drawn after this
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_colour(c_white);
draw_set_alpha(1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Override draw event</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
