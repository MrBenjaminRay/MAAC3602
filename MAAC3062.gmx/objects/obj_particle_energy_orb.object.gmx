<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_particle_energy_orb</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000000</depth>
  <persistent>0</persistent>
  <parentName>obj_particle</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set a high enough lifeLeft so that the particles have time to erupt
// and make it where they need to go, but that they don't last forever
// if they're not killed when they should be killed.
lifeLeft = 10000;

angle = random_range(0, 2*pi);
angleChange = random_range(-.003, .003); // Slight randomized twist
initialSpeed = random_range(.001, .2);
speedChange = .98;
currentSpeed = initialSpeed;

speedTowardsTarget = random_range(0.02, 0.04);
speedTowardsTargetChange = 1.05;
speedTowardsTargetMax = 10;
image_index = irandom_range(0, image_number-1);
image_speed = random_range(0.5, 0.75);
image_alpha = random_range(.7, 1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
    This animation occurs in two parts, and they occur at the same time during
    part of the animation.
    
    First part:  Orbs explode outward from energy drop, with randomized direction 
    (angle) and randomized speed. The speed value starts high, so the particles
    go away from their origin quickly before slowing.  As the explosion speed slows,
    the speed of the second effect ramps up.
    
    Second part:  Orbs become drawn towoards the energy level icon in the room.
    Attraction (speed) is low at first, but then ramps up and the movement has more
    effect on the particles than the first explosion movement.
    
    For a little while, both the explosion momentum and attraction to the energy icon
    are affecting the particle, just at varying levels.
*/

// FIRST PART: Explosion from energy drop

// Calculate next position for the explosion effect based on randomized speed &amp; angle
x += cos(angle) * currentSpeed * global.deltaTime;
y += sin(angle) * currentSpeed * global.deltaTime;

// Tweak angle slightly over time, giving a bit of a curve based
// on the randomized angleChange value
angle += angleChange * global.deltaTime;
currentSpeed *= speedChange;



// SECOND PART: Attraction to Energy Level Icon

// Get direction vector towards energy level indicator
if (object_exists(obj_hud_levelEnergy)) {
    var dir = degtorad(point_direction(x, y, obj_hud_levelEnergy.collectionPointX, obj_hud_levelEnergy.collectionPointY));
} else {
    // This is bad - can't have energy orbs on a level if there's nowhere for them to go (energy level indicator)
    show_debug_message("Level is missing obj_hud_levelEnergy!");
    return 0;
}

speedTowardsTarget *= speedTowardsTargetChange;
if (speedTowardsTarget &gt; speedTowardsTargetMax) {
    speedTowardsTarget = speedTowardsTargetMax;
}
x += cos(dir) * speedTowardsTarget * global.deltaTime;
y -= sin(dir) * speedTowardsTarget * global.deltaTime; // Subtract as y is inverted



// Special condition:  If orb ends up outside of the screen bounds, 
// move it to the same location as the energy level so that it will collide and
// give the amount, and kill the speed. This might happen if the speed of the orb 
// causes it to overshoot the energy level object, in which case collision would 
// not occur.
if (x &lt; view_xview[0] + 10 || x &gt; window_get_width() || y &lt; view_yview[0] + 10 || y &gt; window_get_height()) {
    if (object_exists(obj_hud_levelEnergy)) {
        x = obj_hud_levelEnergy.x;
        y = obj_hud_levelEnergy.y;
        speedTowardsTarget = 0;
        //if (point_in_rectangle(x, y, obj_hud_levelEnergy.x-20, obj_hud_levelEnergy.y-20, obj_hud_levelEnergy.x+20, obj_hud_levelEnergy.y+20)) {
            scr_energy_change(1);
            instance_destroy();
        //}
    } else {
        // Should never get here as we check for obj_hud_levelEnergy to exist earlier in this code
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_hud_levelEnergy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_energy_change(1);
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw in Draw End event so orbs appear in front of level foreground
// (very low depth still doesn't push an object in front of a foreground)

draw_self();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw in Draw End</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
