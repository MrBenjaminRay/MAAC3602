<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_entity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ANIMATION:
animationSpeed = 0.125;
image_speed = 0.125;

// Enemy Types:
//  "Ground"
//  "Air"
type = "Ground";

outOfBoundsBounce = true;   // Automatically reverse direction &amp; restart movement when going out of bounds
                            // When false, they are pushed back into the room &amp; stopped.
wallBounce = true;      // Automatically switch direction &amp; restart movement when hitting a wall.
                        // When false, they are simply pushed out of the wall &amp; stopped.

attackRate = 240;
attackRange = sprite_width/4;

// Automatically set horizontal movement to move towards player (if exists), otherwise random left/right.
scr_entity_startMovingTowardsPlayerOrRandom();

age = 0;                    // Age of enemy (milliseconds since spawning) - for lag prevention purposes.

energyDrop = 0;

// TOWER-SPECIFIC DATA (Sloth):
freeze_stacks = 0;                                  // The number of stacks.
freeze_maxStacks = 20;                              // The max number of stacks.
freeze_isFrozen = false;                            // Whether or not the enemy is frozen.
//freeze_frozenTime = scr_misc_secondsToDeltaTime(4); // The time to remain frozen, in delta time.
freeze_frozenTimeCounter = 0;                       // The amount of time the enemy has been frozen.

freezeMultiplier = 0;       // The current number of times the enemy has been hit by the freeze tower.
maxFreezeMultiplier = 20;   // The number of freezeMultipliers until the enemy is frozen.
isFrozen = false;           // Whether or not the enemy is currently frozen.
frozenTime = 4096;          // The amount of time that the enemy will remain frozen for. 
frozenTimeCounter = 0;      // The amount of time that the enemy has been frozen for.

// TOWER-SPECIFIC DATA (Flame):
flame_minDamage = 0.5;                                  // The min amnt of dmg applied per-stack.
flame_maxDamage = 1;                                    // The max amnt of dmg applied per-stack.
flame_stacks = 0;                                       // The number of stacks.
flame_maxStacks = 5;                                    // The max number of stacks.
flame_stackLifetime = scr_misc_secondsToDeltaTime(2);   // The time before a stack is removed, in delta time.
flame_stackLifetimeCounter = 0;                         // The amount of time since the last stack was removed.
flame_damageTime = scr_misc_secondsToDeltaTime(0.5);    // The time between stack damage applications.
flame_damageTimeCounter = 0;                            // The amount of time since the last stack damage application.

// ABILITY-SPECIFIC DATA (Ability #2/AbilityB/Snake Ability):
isRootedBySnake = false;
timeSpentRooted = 0;
timeUntilUnrooted = 0;

// Clamp the enemy onto the tile it's spawned above:
while (place_meeting(x, y, obj_physicsTile) == false) {
    y++;
}



//set colour blends for levels 5-8
if (scr_getLevelId() == 4) {
    image_blend = c_blue; //water
} else if (scr_getLevelId() == 5) {
    image_blend = make_color_rgb(40, 40, 40); //asteroid
}
else if (scr_getLevelId() == 6) {
    image_blend = make_color_rgb(255, 0, 0); //mars
}
else if (scr_getLevelId() == 7) {
    image_blend = make_color_rgb(128, 0, 0); //earth
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>601</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_execute_script</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>9</kind>
            <script>scr_drop_energy</script>
          </argument>
          <argument>
            <kind>0</kind>
            <string>x + (sprite_width/2)</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>y + (sprite_height/2)</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>energyDrop</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Handle Attack Timing</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.state == "Paused") {
    return 0;
}

if (attackRateCounter &lt; attackRate) {
    attackRateCounter += global.deltaTime;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Handle Attacking</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


if (attackRateCounter &gt;= attackRate) {
    var nearestPlayer = scr_misc_gearNearestObjectOfType(attackRange, obj_player);
    var nearestMiner = scr_misc_gearNearestObjectOfType(attackRange + 15, obj_miner);
    var nearestTower = scr_misc_gearNearestObjectOfType(attackRange, obj_tower);
    
    var hasAttacked = false;
    
    // An enemy will attack targets in the order of:
    //      1 - Player
    //      2 - Miner
    //      3 - Tower
    if (nearestPlayer != noone) {
        if (nearestPlayer.x &lt;= x) {
            if (attackDamage &gt; 15) {
                nearestPlayer.x -= attackDamage;
            } else {
                nearestPlayer.x -= 15;
            }
        } else {
            if (attackDamage &gt; 15) {
                nearestPlayer.x += attackDamage;
            } else {
                nearestPlayer.x += 15;
            }
        }
        
        if (nearestPlayer.x &lt; 0) {
            nearestPlayer.x = nearestPlayer.sprite_width/2;
        } else if (other.x &gt; room_width) {
            nearestPlayer.x = room_width - nearestPlayer.sprite_width/2;
        }
        
        scr_entity_dealDamage(nearestPlayer, attackDamage);
        attackRateCounter = 0;
    }
    
    if (hasAttacked == false and nearestMiner != noone) {
        scr_entity_dealDamage(nearestMiner, attackDamage);
        attackRateCounter = 0;
    }
    
    if (hasAttacked == false and nearestTower != noone) {
        scr_entity_dealDamage(nearestTower, attackDamage);
        attackRateCounter = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Handle Movement</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var nearestMiner = instance_nearest(x, y, obj_miner);
var minerNearby = false;

if (nearestMiner != noone) {
    minerNearby = distance_to_point(nearestMiner.x, nearestMiner.y) &lt;= attackRange;
}

// HANDLE STUFF THAT MAKES ENEMIES STOP OR SLOW DOWN
if (isRootedBySnake) {
    // Complete movement freeze by setting slow effect level to 0
    movementSlowEffectLevel = 0;
    // Also force movement speed to 0 so speed has to accelerate again after snake rooting
    speed_x = 0;
} else if (minerNearby) {
    // Force movement to 0 when attacking miner by setting slow effect level to 0 (bit of a hack, but it works)
    movementSlowEffectLevel = 0;
    // Also force movement speed to 0 so speed has to accelerate again after passing miner
    speed_x = 0;
} else {
    // Set slow effect level based on freeze stacks
    movementSlowEffectLevel = (1 - (freeze_stacks/freeze_maxStacks));
}

// RANDOM MOVEMENT DIRECTION IF DESIRED SPEED IS 0
// Enemy is the scren, but not moving, so set a random direction
if (movementSpeedDesired == 0) {
    // Enemy is not moving horizontally, so we set a movement speed, hopefully
    // moving towards player, otherwise random left/right.
    //scr_entity_moveTowardsPlayerOrRandom();
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Freeze Tower Effects</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// If frozen, atttempt to slowly unfreeze (sloth will freeze faster than this ufreezes)
// A good side-effect of this is that instead of the sloth always freezing enemies completely,
// this allows them to move extremely slowly
if (freeze_stacks &gt; 0) {
    freeze_stacks -= 0.5;
}

// Don't allow negative stacks:
if (freeze_stacks &lt; 0) {
    freeze_stacks = 0;
}

// Don't allow stacks to exceed the maximum:
if (freeze_stacks &gt; freeze_maxStacks) {
    freeze_stacks = freeze_maxStacks;
}

// Set as frozen if possible:
if (freeze_stacks == freeze_maxStacks) {
    // If frozen, increment counter and check for unfreeze.
    // Else, set as frozen.
    if (freeze_isFrozen) {
        freeze_frozenTimeCounter += global.deltaTime;
        
        // Unfreeze if possible:
        // REMOVED 2017/04/01 - Sloth can freeze enemy indefinitely
        //if (freeze_frozenTimeCounter &gt;= freeze_frozenTime) {
        //    freeze_isFrozen = false;
        //    freeze_frozenTimeCounter = 0;
        //    freeze_stacks = 0;
        //}
    } else {
        freeze_isFrozen = true;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Flame Tower Effects</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Don't allow more than the max number of stacks:
if (flame_stacks &gt; flame_maxStacks) {
    flame_stacks = flame_maxStacks;
}

if (flame_stacks &gt; 0) {
    // Increment Counter:
    flame_stackLifetimeCounter += global.deltaTime;
    flame_damageTimeCounter += global.deltaTime;
    
    // Remove a stack if the counter is high enough:
    if (flame_stackLifetimeCounter &gt;= flame_stackLifetime) {
        flame_stacks--;
        flame_stackLifetimeCounter = 0;
    }
    
    // Apply damage if the counter is high enough:
    if (flame_damageTimeCounter &gt;= flame_damageTime) {
        // Handle stack damage:
        var minDamage = flame_stacks * flame_minDamage;
        var maxDamage = flame_stacks * flame_maxDamage;
        scr_entity_dealDamage(self, irandom_range(minDamage, maxDamage));
        
        flame_damageTimeCounter = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Increase Age</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Increment age
age += global.deltaTime;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Handle Snake Root</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>timeSpentRooted += global.deltaTime;

if (timeSpentRooted &gt;= timeUntilUnrooted) {
    isRootedBySnake = false;
    timeSpentRooted = 0;
    timeUntilUnrooted = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
