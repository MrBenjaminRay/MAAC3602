<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_tower_mechaGoat_left</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>40</depth>
  <persistent>0</persistent>
  <parentName>obj_tower</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_entity_loadTowerData(6);

// Special stuff just for goat
enemyTypePriority[0] = obj_enemy_boss_large_A;
enemyTypePriority[1] = obj_enemy_boss_large_B;
enemyTypePriority[2] = obj_enemy_boss_large_C;
enemyTypePriority[3] = obj_enemy_boss_large_D;
enemyTypePriority[4] = obj_enemy_boss_mini_A;
enemyTypePriority[5] = obj_enemy_boss_mini_B;
enemyTypePriority[6] = obj_enemy_boss_mini_C;
enemyTypePriority[7] = obj_enemy_boss_mini_D;
enemyTypePriority[8] = obj_enemy_ground_spider_large;
enemyTypePriority[9] = obj_enemy_ground_jackal;
enemyTypePriority[10] = obj_enemy_ground_heavy;
enemyTypePriority[11] = obj_enemy_air_heavy;
enemyTypePriority[12] = obj_enemy_ground_medium;
enemyTypePriority[13] = obj_enemy_air_light;
enemyTypePriority[14] = obj_enemy_ground_spider_small;
enemyTypePriority[15] = obj_enemy_ground_light;
enemyTypePriority[16] = obj_enemy_ground;    // In case a ground type was not explicitly mentioned above
enemyTypePriority[17] = obj_enemy_air;       // In case a ground type was not explicitly mentioned above
enemyTypePriority[18] = obj_enemy;           // In case a ground type was not explicitly mentioned above

image_index = 0;
image_speed = 0;
mouthState = 0; // 0 = nothing, 1 = opening, 2 = open (delay), 3 = closing
mouthAnimationSpeed = .1; // Speed to use when opening and closing (closing will be negative)
mouthOpenTime = 1000; // Amount of time to leave mouth open before closing
mouthOpenTimeElapsed = 0;

// Reference to goat projectile. Will be noone when no goat is in the air.
goatObj = noone;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(x, y, obj_tower_destroyed_mechaGoat);
scr_create_explosion(x + sprite_width/2, y + sprite_height/2, 'Tower');
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Override obj_entity's step event.</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.state == "Paused") {
    return 0;
}

if (attackRateCounter &gt;= attackRate) {
    attackRateCounter = 0;
    
    // Can only fire if this tower doesn't already have a goat out there flying around
    if (!instance_exists(goatObj)) {
    
        // Search for potential targets in order, aiming for biggest/baddest ones first (array defined in create code)
        var nearestEnemy;
        for (var i = 0; i &lt; array_length_1d(enemyTypePriority); i++) {
            nearestEnemy = scr_misc_gearNearestObjectOfType(attackRange, enemyTypePriority[i]);
            if (nearestEnemy != noone) {
                break;
            }
        }
    
        if (nearestEnemy != noone) {
            // For the goat tower, just decide whether target is more to left or right,
            // mirror the tower if needed, open the mouth, spawn the projectile, set the 
            // projectile's target object, then close the mouth.
            var enemyX = nearestEnemy.x + nearestEnemy.sprite_width/2;
            var enemyY = nearestEnemy.y + nearestEnemy.sprite_height/2;
            var projDir;
            var projDirAimed; // Angle towards which the goat is aimed (different from movement)
            var projFlip = false; // True when sending projectile to the left (flip vertically), false when right
            
            if (enemyX &lt; x + sprite_width/2) {
                // Target is currently to the left of tower's center point
                sprite_index = spr_tower_mechaGoat_left;
                projDir = 150;
                projDirAim = projDir;
                projFlip = true;
            } else {
                // Target is currently to the right (or exactly same) as tower's center point
                sprite_index = spr_tower_mechaGoat_right;
                projDir = 30;
                projDirAim = projDir;
                projFlip = false;
            }
    
            // Spawn projectile (use offset to spawn goat behind tower's mouth):
            var projX = x + weaponXOffset;
            var projY = y + weaponYOffset;
            var proj = scr_spawn_projectile(obj_projectile_mechaGoat, projX, projY, nearestEnemy, false, attackDamage);
            proj.direction = projDir;
            proj.direction_aim = projDirAim;
            proj.targetEnemy = nearestEnemy;
            proj.depth = depth + 1; // Goat initially appears behind tower (will be changed to goat's depthAfterLaunch after launch)
            proj.projFlip = projFlip;

            // Get reference to goat object
            goatObj = proj;
            
            audio_play_sound(snd_basicTower, 0, false);
            audio_sound_gain(snd_basicTower, 0.4, 0);
            
            // Show projectile spawn effect: (NONE FOR GOAT, UNLESS WE THINK OF SOMETHING FUNNY)
            //scr_create_explosion(projX, projY, 'Flash');
            
            // Start kickback (NONE FOR GOAT)
            //scr_entity_weaponKickback_Start();
            
            // Start the mouth open-close animation
            mouthState = 1;
            image_index = 0;
            image_speed = mouthAnimationSpeed;
        }
    }
}

attackRateCounter += global.deltaTime;

if (mouthState == 0) {
    // Mouth not doing anything
    
} else if (mouthState == 1) {
    // Mouth opening
    if (image_index &lt; image_number) {
        // State still valid, so continue
        
    } else {
        // We are at the last frame, so stop animation and start the next step
        image_speed = 0;
        mouthState = 2;
        mouthOpenTimeElapsed = 0;
    }
} else if (mouthState == 2) {
    // Mouth open, so increment time counter
    if (mouthOpenTimeElapsed &lt; mouthOpenTime) {
        mouthOpenTimeElapsed += global.deltaTime;
    } else {
        // Mouth has been open long enough, so start the next step
        mouthState = 3;
        image_speed = -mouthAnimationSpeed;
    }
} else if (mouthState == 3) {
    // Mouth closing
    if (image_index &gt; 0) {
        // Continue reverse animation to close mouth   
    } else {
        // Mouth is closed, so stop animation and switch to step 0
        image_index = 0;
        image_speed = 0;
        mouthState = 0;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
