<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_sloth_flying</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-45</depth>
  <persistent>0</persistent>
  <parentName>obj_projectile</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>xDest = x; // The destination x-axis coordinate.
yDest = y; // The destination y-axis coordinate.

scr_particle_projectile_addsmoketrail(.05);
audio_play_sound(snd_mortarFlying, 0, false);
audio_sound_gain(snd_mortarFlying, 0.5, 0);

movementSpeed = 0; // Don't use this for sloth

freezeInterval = 100; // How long to wait before incrementing enemy freeze multiplier
timeToNextFreeze = 0; // Time before the sloth can increment the enemy freeze multiplier

// Parameters for sloth flight (set speed &amp; gravity to these)
flightSpeed = 4;
flightGravity = 0;

retractSpeed = 1;
retractGravity = .1;

swingAngleChange = 0; // Swing angle change
swingAngleChange_Increase = 0.0007; // Increase in speed when swing is falling towards bottom center
swingAngleChange_Decrease = -0.0011; // Decrease in speed when swing is slowing after passing bottom center

// Parameters for sloth retraction
xHome = 0; // x coordinate for cannon mount point on tower (will retract to here)
yHome = 0; // y coordinate for cannon mount point on tower (will retract to here)

// Sloth needs to know which enemy he is in love with
targetEnemy = noone;

// Maximum rope length, which will be the same as the tower's attackRange when projectile created.
// Will include any increased range due to upgrades.
// Rope length will stop sloth from flying beyond the range of the tower, even if the target he is
// flying towards has just walked out of rance. Like a dog hitting the end of his leash.
ropeMaxLength = 0;

// Current rope length. Will not exceed ropeMaxLength, which is same as tower's attackRange
// When the sloth is flying out of cannon, ropeLength will be equivalent to distance from cannon's
// mount point on the tower (centered horizontally). Once the rope hits max length, the rope length
// stays at ropeMaxLength while sloth falls and rope begins to retract.  Once sloth hits target, rope
// length continues to update as the enemy moves around, but if the enemy goes out of range of rope max,
// the sloth disconnects from the enemy and drops.
ropeLength = 0;

// Mode FLY, HUG, FALL, SWING
mode = "FLY"; // Default mode for sloth projectile

// Set high max life (3 min)
maxLife = 180000;

//Set the alarm[0] event that handles the heart projectiles (first alarm will be next step)
alarm[0]=1;

// Create the emitter(s)
emitter = part_emitter_create(global.partSystem_sloth);

//Set up the area that will emit particles
part_emitter_region(global.partSystem_sloth, emitter, x-10, x+10, y-10, y+10, ps_shape_ellipse, ps_distr_gaussian);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Emit Hearts</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Check how many ground enemies the sloth is colliding with (only if sloth hugging the target)
var enemiesSlowed = 0;
if (mode == "HUG") {
    with (obj_enemy_ground) {
        if (place_meeting(x, y, other)) {
            enemiesSlowed += 1;
        }
    }
}

// Calculate a spawning ratio based on how many enemies the sloth is colliding with at the moment
heartSpawningRate = max(1, enemiesSlowed);

// Set emitter area (a small area around the sloth's origin)
part_emitter_region(global.partSystem_sloth, emitter, x-10, x+10, y-10, y+10, ps_shape_ellipse, ps_distr_gaussian);

// Burst some smaller, red hearts
part_emitter_burst(global.partSystem_sloth, emitter, global.part_sloth1, irandom_range(heartSpawningRate/2, heartSpawningRate * 1.25));

// Burst some larger, pink hearts (only if at least 1 enemy being slowed, which only happens 
// while sloth is "hugging" the designated target)
if (enemiesSlowed &gt;= 1) {
    part_emitter_burst(global.partSystem_sloth, emitter, global.part_sloth2, irandom_range(heartSpawningRate/2, heartSpawningRate));
}

// Reset the alarm with some randomization
alarm[0]=irandom_range(20, 30);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var enemyCenterX;
var enemyCenterY;

if (instance_exists(targetEnemy)) {
    enemyCenterX = targetEnemy.x + targetEnemy.sprite_width/2;
    enemyCenterY = targetEnemy.y + targetEnemy.sprite_height/2;
    if (mode == "FLY") {
        // Sloth always rotates towards its desired target when flying
        image_angle = point_direction(x, y, enemyCenterX, enemyCenterY) + 180; // Sloth sprite is rotated 180
    }
}

if (mode == "FLY" || mode == "FALL") {
    // Update rope length
    ropeLength = point_distance(x, y, xHome, yHome);
}


if (ropeLength &gt; ropeMaxLength) {
    // Rope length exceeds maximum
    // Pull sloth back towards tower until length within range    
    var angleFromHomeDeg = point_direction(xHome, yHome, x, y);
    var angleFromHomeRad = degtorad(angleFromHomeDeg);
    x = xHome + cos(angleFromHomeRad) * ropeMaxLength;
    y = yHome - sin(angleFromHomeRad) * ropeMaxLength; // Minus as -y is up
    
    // Update rope length after pulling back within range
    ropeLength = point_distance(x, y, xHome, yHome);

    // Stop whatever we're doing
    if (mode == "FLY") {
        scr_sloth_startFall();
        // Sloth hangs by feet when being retracted
        image_angle = angleFromHomeDeg + 180;
    } else if (mode == "HUG") {
        scr_sloth_startFall();
    } else if (mode == "FALL") {
        scr_sloth_startSwing();
    }
}

var angleFromHomeDeg;
var angleFromHomeRad;

if (mode == "FALL" || mode == "SWING") {
    // Retract rope during fall and swing modes
    ropeLength -= retractSpeed;
    
    // Pull sloth back towards tower based on new rope length
    angleFromHomeDeg = point_direction(xHome, yHome, x, y);
    angleFromHomeRad = degtorad(angleFromHomeDeg);
    x = xHome + cos(angleFromHomeRad) * ropeLength;
    y = yHome - sin(angleFromHomeRad) * ropeLength; // Minus as -y is up
    
    // Destroy projectile once fully retracted
    if (point_distance(x, y, xHome, yHome) &lt; 20) {
        instance_destroy()
    }
    

}

if (mode == "FALL") {
    // Nothing to do

} else if (mode == "SWING") {
    // Swing the sloth on the rope like a pendulum
    if (x &gt; xHome) {
        // Sloth is to the RIGHT of the center swing point
        if (swingAngleChange &gt; 0) {
            // Sloth swing motion going from center towards right, so slow it down
            swingAngleChange += swingAngleChange_Decrease;
        } else {
            // Sloth swing motion going from right towards center, so speed it up
            swingAngleChange -= swingAngleChange_Increase;
        }
    } else if (x &lt; xHome) {
        // Sloth is to the LEFT of the center swing point
        if (swingAngleChange &gt;= 0) {
            // Sloth swing motion going from let towards center, so speed it up
            swingAngleChange += swingAngleChange_Increase;
        } else {
            // Sloth swing motion going from center towards left, so slow it down
            swingAngleChange -= swingAngleChange_Decrease;
        }
    }
    
    angleFromHomeRad += swingAngleChange;

    x = xHome + cos(angleFromHomeRad) * ropeLength;
    y = yHome - sin(angleFromHomeRad) * ropeLength; // Minus as -y is up

    // Sloth hangs by feet when being retracted
    image_angle = angleFromHomeDeg + 180;

}

if (mode == "HUG") {
    if (instance_exists(targetEnemy)) {
        var xscale = 1;
        var xoffset = 33;
        if (targetEnemy.speed_x &gt;= 0) {
            // Flip sprite when enemy moving to the right
            xscale = -1;
            xoffset = 38;
        }
        // Keep the sloth on the enemy
        x = targetEnemy.x + targetEnemy.sprite_width/2 * xscale + xoffset;
        y = targetEnemy.y + targetEnemy.sprite_height - sprite_get_height(spr_sloth_dragging)+13;
    } else {
        // Enemy has been destroyed (some other attacker), so drop
        scr_sloth_startFall();
    }
}

scr_projectile_enforceMaxLife();


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy_ground">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// If colliding with the enemy this projectile was sent to target,
// attach and slow.

if (instance_exists(targetEnemy)) {
    if(targetEnemy == other) {
        // This is the enemy that this projectile was sent to target
        // Start hugging if not already hugging
        if (mode == "FLY") {
            scr_sloth_startHug();
        }
    }
    // Apply slow effect to all enemies in range
    if (mode == "HUG") {
        
        other.freeze_stacks++; // Max freeze stacks enforced in enemy step code
        
        // This (below) worked when we were freezing 1 enemy, but this won't work when sloth
        // freezes multiple enemies. We would need a per-enemy freeze, and we don't need
        // to do any of that anymore.
        //// If counter has elapsed, increase freeze effect
        //if (timeToNextFreeze == 0) {
        //    targetEnemy.freeze_stacks++; // Max freeze stacks enforced in enemy step code
        //    timeToNextFreeze = freezeInterval;
        //} else {
        //    timeToNextFreeze -= global.deltaTime;
        //    timeToNextFreeze = clamp(timeToNextFreeze, 0, freezeInterval);
        //}    
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw the flying sprite if not hugging an enemy, 
// and draw the hugging sprite if hugging an enemy

if (mode == "HUG" &amp;&amp; instance_exists(targetEnemy)) {

    // Mirror image when enemy moving right
    var xscale = 1;
    if (targetEnemy.speed_x &gt;= 0) {
        xscale = -1;
    }

    draw_sprite_ext(
        spr_sloth_dragging, 
        0, 
        x, 
        y,
        xscale,
        1,
        0,
        c_white,
        1
    );
} else {
    draw_self();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
